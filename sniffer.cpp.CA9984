#include "sniffer.h"
#include "ui_sniffer.h"
#include <stdlib.h>

Sniffer::Sniffer(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::Sniffer)
{
    ui->setupUi(this);
    uiHander = ui;

    connect(ui->actionMenuSelectAdapter, SIGNAL(triggered()), this, SLOT(on_actionSelectAdapter_triggered()));
    connect(ui->actionMenuStart, SIGNAL(triggered()), this, SLOT(on_actionStart_triggered()));
    connect(ui->actionMenuPause, SIGNAL(triggered()), this, SLOT(on_actionPause_triggered()));
    connect(ui->actionMenuHelp, SIGNAL(triggered()), this, SLOT(on_actionHelp_triggered()));

    setHelpEnabled(false);
    setPauseEnabled(false);
    setStartEnabled(false);

    setTableViewHeader();
}

Ui::Sniffer *Sniffer::uiHander = NULL;

Sniffer::~Sniffer()
{
    delete ui;
}



void Sniffer::on_actionSelectAdapter_triggered()
{
    Adapter adapter;
    connect(&adapter, SIGNAL(itemClicked(const QString&)), this, SLOT(on_adapter_itemClicked(const QString&)));
    adapter.exec();
}


void Sniffer::on_actionStart_triggered()
{
    ui->tableViewPakage->horizontalHeader()->show();
    setStartEnabled(false);
    setPauseEnabled(true);
}

void Sniffer::on_actionPause_triggered()
{

}

void Sniffer::on_actionHelp_triggered()
{

}

void Sniffer::on_actionExit_triggered()
{
    this->close();
}

/* 每次捕获到数据包时，libpcap都会自动调用这个回调函数 */
void Sniffer::packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
    QStandardItemModel *model = (QStandardItemModel*)Sniffer::uiHander->tableViewPackge->model();
    struct tm *ltime;
    char timestr[16];
    time_t local_tv_sec;


    /* 将时间戳转换成可识别的格式 */
    local_tv_sec = header->ts.tv_sec;
    ltime=localtime(&local_tv_sec);
    strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);

    QStandardItem *item1=new QStandardItem(timestr);
    QStandardItem *item2=new QStandardItem(QString::number(header->ts.tv_usec));
    QStandardItem *item3=new QStandardItem(QString::number(header->len));
    QList<QStandardItem*> item;
    item<<item1<<item2<<item3;
    model->appendRow(item);
}

void Sniffer::on_adapter_itemClicked(const QString &name)
{
    statusBar()->showMessage(tr("已选择设备: ") + Device::instance()->getDescriptionByName(name));
    char errbuf[PCAP_ERRBUF_SIZE];
    const char *dname= name.toStdString().c_str();
    //打开设备
    if ( (adhandle= pcap_open(dname,          // 设备名
                              65536,            // 65535保证能捕获到不同数据链路层上的每个数据包的全部内容
                              PCAP_OPENFLAG_PROMISCUOUS,    // 混杂模式
                              1000,             // 读取超时时间
                              NULL,             // 远程机器验证
                              errbuf            // 错误缓冲池
                              )) == NULL)
    {
        QString errname = name;
        QMessageBox::warning(NULL,"error","\nUnable to open the adapter. "+ errname +"is not supported by WinPcap\n");
        return;
    }
    this->setStartEnabled(true);
}

void Sniffer::setHelpEnabled(bool enabled)
{
    ui->actionHelp->setEnabled(enabled);
    ui->actionMenuHelp->setEnabled(enabled);
}

void Sniffer::setPauseEnabled(bool enabled)
{
    ui->actionPause->setEnabled(enabled);
    ui->actionMenuPause->setEnabled(enabled);
}

void Sniffer::setStartEnabled(bool enabled)
{
    ui->actionStart->setEnabled(enabled);
    ui->actionMenuStart->setEnabled(enabled);
}


void Sniffer::setTableViewHeader()
{
    QStandardItemModel *model = new QStandardItemModel();
    //列
    QStringList headerList;
    headerList << "time" << "usec" << "head";
    model->setHorizontalHeaderLabels(headerList);
    ui->tableViewPackge->horizontalHeader()->setStretchLastSection(true);
    ui->tableViewPackge->setModel(model);
    ui->tableViewPackge->verticalHeader()->hide();
    ui->tableViewPackge->horizontalHeader()->hide();

    //设置选中时为整行选中
    ui->tableViewPackge->setSelectionBehavior(QAbstractItemView::SelectRows);
    //设置表格的单元为只读属性，即不能编辑
    ui->tableViewPackge->setEditTriggers(QAbstractItemView::NoEditTriggers);
}
